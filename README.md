cat > README.md << 'EOF'
# Form Filler Automation

This project automates filling a web form using data from a mock JSON file and an LLM (GPT-4O) to drive the mapping between HTML form fields and the provided data. The automation is built with Playwright for browser interaction, LangChain for prompt management, and Pydantic for data validation.

## Why This Approach?

### Reasons for This Design

- **Modularity:**  
  The project is broken into several modules (data, LLM mapping, dynamic field filling, static fallbacks, and the main form filler). This makes the code easier to maintain, extend, and test.

- **Separation of Concerns:**  
  - **Data Module:** Contains all mock data in one place.
  - **LLM Mapper:** Handles generating a mapping between HTML fields and mock data using a large language model.
  - **Field Filler:** Contains dynamic field filling logic based on the LLM mapping.
  - **Static Fallbacks:** Provides fallback routines for fields that require hardcoded static actions (e.g. signature dates, additional info, unit info).
  - **Form Filler:** Combines the mapping, dynamic fill, and static fallbacks to automate the entire form process.

- **Flexibility:**  
  By using an LLM for mapping, the system can adapt to slight changes in the HTML structure without significant code changes.

- **Testability:**  
  The modules are isolated and can be unit tested independently.

### Pros

- **Maintainability:** Each module has a clear responsibility.
- **Modular Testing:** Easier to write unit tests for individual components.
- **Extensibility:** Future updates (e.g. additional form sections or new field types) can be added to the appropriate module without changing the entire codebase.
- **Adaptability:** The LLM-driven mapping can adjust to changes in form structure as long as the prompt remains relevant.

### Cons

- **Dependency on LLM:** The quality of the mapping depends on the LLM output. If the LLM output changes or doesn’t match expectations, the automation may fail.
- **Complexity:** The modular and object‑oriented approach adds extra layers of abstraction which might be overkill for very simple forms.
- **Performance:** Using an LLM call for mapping adds network latency compared to a fully hardcoded solution.
- **Error Handling:** The system requires robust error handling in case of mapping or field-filling failures, which can increase code complexity.

## Module Explanations

- **data.py**  
  Contains the complete mock data (mock_data_all_fields) used to fill the form. This module centralizes the data for easier updates and testing.

- **llm_mapper.py**  
  Defines the FieldMapping model using Pydantic and the LLMMapper class. The class sends a prompt (with explicit rules for mapping checkboxes and text fields) to an LLM (GPT-4O) and returns a list of FieldMapping objects.
  
  *Key components:*  
  - FieldMapping: Validates and normalizes mapping data.
  - LLMMapper.get_mapping(): Uses LangChain and ChatOpenAI to produce the mapping.

- **field_filler.py**  
  Contains the fill_field_dynamic function. This function uses the mapping generated by the LLM to interact with the form fields dynamically via Playwright. It includes special handling for checkboxes (such as subject_to_restrictions and client_type) and falls back to generic field-filling logic for text and select fields.

- **static_fallbacks.py**  
  Provides fallback functions for fields that are not handled by the LLM mapping (e.g., signature dates, additional info for Part 6, and unit information). These functions are used after dynamic mapping to ensure all required fields are filled.

- **form_filler.py**  
  The high-level module that ties together the LLM mapping, dynamic field filling, and static fallbacks. It defines the FormFiller class, which contains the main fill_form() method to drive the entire process.

- **run.py**  
  The entry point for execution. This file instantiates the FormFiller class using the target URL and the mock data, then calls its fill_form() method to run the automation.

## Installation

1. **Clone the Repository:**  
   Create a project directory and clone the repository or create the files manually.

       git clone https://github.com/your_username/form-filler-automation.git
       cd form-filler-automation

2. **Create a Virtual Environment (Optional but Recommended):**

       python -m venv venv
       source venv/bin/activate   (or on Windows: venv\Scripts\activate)

3. **Install Required Packages:**  
   Ensure you have a requirements.txt file in the project root with the following contents (for example):

       playwright
       langchain
       openai
       python-dotenv
       pydantic
       asyncio

   Then run:

       pip install -r requirements.txt

4. **Install Playwright Browsers:**

       playwright install

## Running the Application

To run the form-filling process, execute the run.py file:

       python run.py

This script will launch a browser (in non-headless mode) and execute the form-filling process using the provided mock data and the LLM mapping.


## Conclusion

This project demonstrates a modular and object‑oriented approach to automating form filling with a heavy reliance on an LLM for dynamic mapping. While this approach provides flexibility and ease of maintenance, it also introduces dependencies on the LLM output and may add complexity for very simple forms. The structure, however, allows you to test and update individual components without affecting the entire system.
EOF
